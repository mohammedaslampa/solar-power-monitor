
#include "ThingSpeak.h"
#include "secrets.h"
#include <ESP8266WiFi.h>
#include <DNSServer.h>
#include <ESP8266WebServer.h>
#include <WiFiManager.h>    
#include <Wire.h>
#include <SPI.h>
#include "RF24.h"
#include <WiFiUdp.h>
#include <Adafruit_INA219.h>

WiFiClient  client;
Adafruit_INA219 ina219;

RF24 radio(16,16); //ce,csn
byte addresses[][6] = {"1Node","2Node"};
bool m0,m1,m2,m3;
char r1,r2,r3,r4;

#define TRIGGER_PIN 2

int timeout = 120; // seconds to run for

char ssid[] = SECRET_SSID;   // your network SSID (name) 
char pass[] = SECRET_PASS;   // your network password

int keyIndex = 0;            // your network key Index number (needed only for WEP)
unsigned long myChannelNumber = SECRET_CH_ID;
const char * myWriteAPIKey = SECRET_WRITE_APIKEY;
String myStatus = "";


bool solar;
bool battery;
bool load;
bool grid;
const int updatestatus = 0;
unsigned long previousMillis = 0;        // will store last time LED was updated
const long interval = 20000;           // interval at which to blink (milliseconds)

float shuntvoltage = 0;
float busvoltage = 0;
float current_mA = 0;
float loadvoltage = 0;
float power_mW = 0;

void configModeCallback (WiFiManager *myWiFiManager) {
  //entered config mode, make led toggle faster
  Serial.println("connected...yeey :)");
}

void setup() {
  Serial.begin(115200);
  uint32_t currentFrequency;
  pinMode(TRIGGER_PIN, INPUT_PULLUP);
  ina219.begin();
  ina219.setCalibration_16V_400mA(); 
  radio.begin();
  radio.openWritingPipe(addresses[1]);
  radio.openReadingPipe(1,addresses[0]);
  radio.startListening();
      WiFiManager wifiManager;
      wifiManager.setAPCallback(configModeCallback);
      wifiManager.autoConnect("AutoConnectAP");
      ThingSpeak.begin(client);  // Initialize ThingSpeak
      pinMode(updatestatus,OUTPUT);
      solar = 1;
      load = 0;
      grid = 0;
      digitalWrite(updatestatus,HIGH);

}

void loop() {
    if ( digitalRead(TRIGGER_PIN) == LOW) {
    WiFiManager wm;    

    //reset settings - for testing
    //wifiManager.resetSettings();
  
    // set configportal timeout
    wm.setConfigPortalTimeout(timeout);

    if (!wm.startConfigPortal("OnDemandAP")) {
      Serial.println("failed to connect and hit timeout");
      delay(3000);
      //reset and try again, or maybe put it to deep sleep
      ESP.restart();
      delay(5000);
    }

    //if you get here you have connected to the WiFi
    Serial.println("connected...yeey :)");

  }
  unsigned long currentMillis = millis();
  shuntvoltage = ina219.getShuntVoltage_mV();
  busvoltage = ina219.getBusVoltage_V();
  current_mA = ina219.getCurrent_mA();
  power_mW = ina219.getPower_mW();
  loadvoltage = busvoltage + (shuntvoltage / 1000);
  if (busvoltage >14){
    solar =0;
    grid = 0;
    load = 1;
  }
  if (busvoltage <12.3){
    grid = 1;
  }
  else if (busvoltage >12.7){
    grid = 0;
  }
  if (current_mA > abs(1500)){
    load = 0;
  }

  
    char got_time[32] = {0}; 
    
    if( radio.available()){
                                                                    // Variable for the received timestamp
      while (radio.available()) {                                   // While there is data ready
        radio.read( &got_time, sizeof( got_time) );             // Get the payload
      }
     
      radio.stopListening();                                        // First, stop listening so we can talk   
      radio.write( &got_time, sizeof( got_time ) );              // Send the final one back.      
      radio.startListening();                                       // Now, resume listening so we catch the next packets.     
      Serial.print(F("Sent response "));
      Serial.println(got_time);  
      r1 = got_time[1];
      r2 = got_time[3];
      r3 = got_time[5];
      r4 = got_time[7];
   }
   if (r1 == 'a'){ m0=0; }

    else if (r1 == 'b'){ m0 = 1; }

    if (r2 == 'c'){ m1 = 0; }

    else if (r2 == 'd'){ m1 = 1; }

    if (r3 == 'e'){ m2 = 0; }

    else if (r3 == 'f'){ m2 = 1; }

    if (r4 == 'g'){ m3 = 0; }

    else if (r4 == 'h'){ m3 = 1; }

   Serial.print("m0 = ");
   Serial.println(m0);
   Serial.print("m1 = ");
   Serial.println(m1);
   Serial.print("m2 = ");
   Serial.println(m2);
   Serial.print("m3 = ");
   Serial.println(m3);
   Serial.print("Bus Voltage:   "); Serial.print(busvoltage); Serial.println(" V");
   Serial.print("Current:       "); Serial.print(current_mA); Serial.println(" mA");
   Serial.println("");
    if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
  // Connect or reconnect to WiFi
  delay(1);
   WiFi.persistent( false );
  
  if(WiFi.status() != WL_CONNECTED){
    Serial.print("Attempting to connect to SSID: ");
    Serial.println(SECRET_SSID);
    while(WiFi.status() != WL_CONNECTED){
   
      WiFi.begin(ssid, pass);  // Connect to WPA/WPA2 network. Change this line if using open or WEP network
      Serial.print(".");
      delay(1000);     
    } 
    Serial.println("\nConnected.");
  }

  // set the fields with the values
  ThingSpeak.setField(1, current_mA);
  ThingSpeak.setField(2, loadvoltage);
  ThingSpeak.setField(3, power_mW);
  ThingSpeak.setField(4, shuntvoltage);
  ThingSpeak.setField(5, solar);
  ThingSpeak.setField(6, grid);
  ThingSpeak.setField(7, load);


    myStatus = String("OK"); 

  
  // set the status
  ThingSpeak.setStatus(myStatus);
  
  // write to the ThingSpeak channel
  int x = ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);
  if(x == 200){
    Serial.println("Channel update successful.");
    digitalWrite(updatestatus,HIGH);
  }
  else{
    Serial.println("Problem updating channel. HTTP error code " + String(x));
    digitalWrite(updatestatus,LOW);
  }
  delay( 1 );
    }
    }
